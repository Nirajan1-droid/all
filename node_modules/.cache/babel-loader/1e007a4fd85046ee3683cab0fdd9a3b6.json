{"ast":null,"code":"import _toConsumableArray from \"/home/nirajan/withcart/march7build/Unicorn-Classic/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nvar updateQueue = makeQueue();\nvar raf = function raf(fn) {\n  return schedule(fn, updateQueue);\n};\nvar writeQueue = makeQueue();\nraf.write = function (fn) {\n  return schedule(fn, writeQueue);\n};\nvar onStartQueue = makeQueue();\nraf.onStart = function (fn) {\n  return schedule(fn, onStartQueue);\n};\nvar onFrameQueue = makeQueue();\nraf.onFrame = function (fn) {\n  return schedule(fn, onFrameQueue);\n};\nvar onFinishQueue = makeQueue();\nraf.onFinish = function (fn) {\n  return schedule(fn, onFinishQueue);\n};\nvar timeouts = [];\nraf.setTimeout = function (handler, ms) {\n  var time = raf.now() + ms;\n  var cancel = function cancel() {\n    var i = timeouts.findIndex(function (t) {\n      return t.cancel == cancel;\n    });\n    if (~i) timeouts.splice(i, 1);\n    pendingCount -= ~i ? 1 : 0;\n  };\n  var timeout = {\n    time: time,\n    handler: handler,\n    cancel: cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  pendingCount += 1;\n  start();\n  return timeout;\n};\nvar findTimeout = function findTimeout(time) {\n  return ~(~timeouts.findIndex(function (t) {\n    return t.time > time;\n  }) || ~timeouts.length);\n};\nraf.cancel = function (fn) {\n  onStartQueue.delete(fn);\n  onFrameQueue.delete(fn);\n  onFinishQueue.delete(fn);\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = function (fn) {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = function (fn) {\n  var lastArgs;\n  function queuedFn() {\n    try {\n      fn.apply(void 0, _toConsumableArray(lastArgs));\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = function () {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nvar nativeRaf = typeof window != 'undefined' ? window.requestAnimationFrame : function () {};\nraf.use = function (impl) {\n  return nativeRaf = impl;\n};\nraf.now = typeof performance != 'undefined' ? function () {\n  return performance.now();\n} : Date.now;\nraf.batchedUpdates = function (fn) {\n  return fn();\n};\nraf.catch = console.error;\nraf.frameLoop = 'always';\nraf.advance = function () {\n  if (raf.frameLoop !== 'demand') {\n    console.warn('Cannot call the manual advancement of rafz whilst frameLoop is not set as demand');\n  } else {\n    update();\n  }\n};\nvar ts = -1;\nvar pendingCount = 0;\nvar sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    if (raf.frameLoop !== 'demand') {\n      nativeRaf(loop);\n    }\n  }\n}\nfunction stop() {\n  ts = -1;\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  var prevTs = ts;\n  ts = raf.now();\n  var count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), function (t) {\n      return t.handler();\n    });\n    pendingCount -= count;\n  }\n  if (!pendingCount) {\n    stop();\n    return;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  var next = new Set();\n  var current = next;\n  return {\n    add: function add(fn) {\n      pendingCount += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete: function _delete(fn) {\n      pendingCount -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush: function flush(arg) {\n      if (current.size) {\n        next = new Set();\n        pendingCount -= current.size;\n        eachSafely(current, function (fn) {\n          return fn(arg) && next.add(fn);\n        });\n        pendingCount += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach(function (value) {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nvar __raf = {\n  count: function count() {\n    return pendingCount;\n  },\n  isRunning: function isRunning() {\n    return ts >= 0;\n  },\n  clear: function clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    pendingCount = 0;\n  }\n};\nexport { __raf, raf };","map":null,"metadata":{},"sourceType":"module"}